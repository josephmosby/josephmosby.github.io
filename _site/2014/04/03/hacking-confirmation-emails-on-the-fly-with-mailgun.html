<!doctype html>
<html>
	<head>

		<title>josephmosby.com</title>
		<meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" href="/stylesheets/fibonacci.css" />
		<link rel="stylesheet" href="/stylesheets/custom.css" />

		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>

	</head>

	<body>

		<div class="wrapper" id="header">
			<div class="container">
				<div class="row">
					<div class="col-13">
						<a href="/"><h3>JOSEPH MOSBY</h3></a>

						<ul class="menu inline">
							<li><a href="/about">about</a></li>
							<li><a href="/projects">projects</a></li>
							<li><a href="/presentations">presentations</a></li>
							<li><a href="/now">now</a></li>
							<li><a href="/feed/atom.xml">subscribe</a></li>
						</ul>

						<a id="hamburger" href="#">MENU</a>
					</div>
				</div>
			</div>
		</div>

		<div class="wrapper" id="dropdown">
			<div class="container">
				<div class="row">
					<div class="col-13">
						<ul class="menu dropdown">
							<li><a href="/about">about</a></li>
							<li><a href="/projects">projects</a></li>
							<li><a href="/presentations">presentations</a></li>
							<li><a href="/now">now</a></li>
						</ul>
					</div>
				</div>
			</div>
		</div>

		<div class="wrapper" id="main">
			<div class="container">
				<div class="row">
	<div class="col-3">
		<a href="/2014/04/03/hacking-confirmation-emails-on-the-fly-with-mailgun.html"><h3>Hacking Confirmation Emails on the Fly with Mailgun</h3></a>
	</div>
	<div class="col-8">
		<p>I just finished slinging together some code for a confirmation email system for an email advocacy campaign using <a href="http://corporate.cqrollcall.com/cqrcengage">CQRC Engage</a>. Engage has a fairly simple set of tricks: it provides you with a Javascript-based widget to write a letter to your legislators, then submits that letter through whichever digital channel the legislator uses. As part of its process, it runs a check to find your particular legislator based on street address and postal code, then tailors the messages for that particular person. Engage doesn’t have an email confirmation sent to you as part of your advocacy, so I built one.</p>

<p>Engage accepts letter submissions via that Javascript widget, then stores data about that advocate, the target, and the message itself in a database accessible via an API. This is all we need to begin constructing our confirmation email system. We’re going to use <a href="http://www.mailgun.com">Mailgun</a> for this task, which is an API-based system that accepts HTTP POST requests and turns them into emails at your command. Without further ado, let’s start building.</p>

<p>I’m first going to build out a series of tiny classes that I’ll use to power my app. In this case, we’ll need four: one for the Advocate who sent a message, one for the Target, one for the Sent Message, and one for the Confirmation Email. They look something like this:</p>

<p>```python
class Advocate:
	def <strong>init</strong>(self, first_name, last_name, email):
		self.first_name = first_name
		self.last_name = last_name
		self.email = email</p>

<p>class Target:
	def <strong>init</strong>(self, first_name, last_name, title):
		self.first_name = first_name
		self.last_name = last_name
		self.title = title</p>

<p>class SentMessage:
	def <strong>init</strong>(self, sender, recipients, message_subject, message_text):
		self.sender = sender # who should be an Advocate
		self.recipients = recipients # a list of Targets
		self.message_subject = message_subject
		self.message_text = message_text</p>

<p>class ConfirmationEmail:
	def <strong>init</strong>(self, sent_message):
		self.message_sent = sent_message
```</p>

<p>This is all stuff I’m going to extract from Engage without any further processing. I’m also going to go ahead and construct my confirmation email template using Jinja’s syntax, which will accept data from these classes you see above.</p>

<p>```</p>
<html>
	<head>
		<meta charset="UTF-8" />
	</head>
	<body>
		<p>Dear {{ first_name }} {{ last_name }}:</p>
		
		<p>{{ confirmation_leadin }}</p>
		
		{% for recipient in recipients  %}
			{{ recipient.first_name }} {{ recipient.last_name }}, {{ recipient.title }}
			<br />
		{% endfor %}
		
		<br />
		
		<p>SUBJECT: {{ message_subject }}</p>
		
		{{ message_text }}
	</body>
</html>
<p>```</p>

<p>So far so good. You can see here that we’ve got a “confirmation_leadin” variable that doesn’t seem to line up with any of our other tags. We added some introductory text into our emails as a “thank you” before including the text of the message and the list of targets it was sent to. Next step is to add on some basic work to begin converting the plain text messages out of Engage into HTML-based messages using <a href="https://pythonhosted.org/Markdown/reference.html">Markdown</a>. Then we’ll use that, along with some of the data from our classes, to populate our Jinja template.</p>

<p>```python
# other lines truncated for brevity
class ConfirmationEmail: 
	def <strong>init</strong>(self, sent_message):
		self.message_sent = sent_message
		self.sanitized_message = markdown.markdown(sent_message.message_text, safe_mode=’replace’)</p>

<pre><code>def create_confirmation_text(self):
	self.confirmation_message = template.render( 
								{"first_name" : self.message_sent.sender.first_name,
							   	"last_name" : self.message_sent.sender.last_name, 
							   	"targets" : self.message_sent.recipients,
							   	"confirmation_leadin" : CONFIRMATION_LEADIN,
							   	"message_subject" : self.message_sent.message_subject,
							   	"message_text" : self.sanitized_message}) ```
</code></pre>

<p>We’re almost there! But now we just need to actually fire off that email, which requires a simple HTTP request using the <a href="http://docs.python-requests.org/en/latest/">requests</a> library.</p>

<p>```python
# other lines truncated for brevity
class ConfirmationEmail: 
	def <strong>init</strong>(self, sent_message):
		self.message_sent = sent_message
		self.sanitized_message = markdown.markdown(sent_message.message_text, safe_mode=’replace’)</p>

<pre><code>def create_confirmation_text(self):
	self.confirmation_message = template.render( 
								{"first_name" : self.message_sent.sender.first_name,
							   	"last_name" : self.message_sent.sender.last_name, 
							   	"targets" : self.message_sent.recipients,
							   	"confirmation_leadin" : CONFIRMATION_LEADIN,
							   	"message_subject" : self.message_sent.message_subject,
							   	"message_text" : self.sanitized_message})

def send_confirmation_message(self):
	return requests.post(MAILGUN_DOMAIN, auth=("api",API_KEY), 
							data={"from": DEFAULT_SENDER,
								  "to": [self.message_sent.sender.email],
								  "subject": CONFIRMATION_SUBJECT,
								  "html": self.confirmation_message}) ```
</code></pre>

<p>We need one final bit to tie it all together - our script that checks the Engage system for new messages, downloads the data and then generates email templates out of it. I’m using pseudocode for some of the Engage API calls, but you’ll get the general idea.</p>

<p>```python
if <strong>name</strong> == “<strong>main</strong>”:
	token = cq.login(‘user’,’password’)
	actions = getActions(token)</p>

<pre><code># store Actions to our owned database
# the StoreActions formula was all written to check for anything already in the database and filter out those results

conn = db.connect('db-location')	
storeActions(conn, actions)

# now we retrieve unconfirmed actions
# this returns me a dictionary in the format { advocateId: {messageId: X, targets: [Y, Z, ...]}}  

unconfirmed = cq.retrieveAllUnconfirmed(conn)

for advocateId in unconfirmed.keys():
	advocate = cq.getAdvocate(token, advocateId)
	sender = Advocate(first_name = advocate["first_name"], last_name = advocate["last_name"], email = advocate["email"])
	recipients = []
	for targetId in unconfirmed[advocateId]["targets"]:
		target = cq.getTarget(token, targetId)
		recipients.append(Target(first_name = target["first_name"], last_name = target["last_name"], title = target["title"]))
	
	message_delivered = cq.getMessage(token, unconfirmed[advocateId]["messageId"])
	sent_message = SentMessage(sender = sender, recipients = recipients, message_subject = message_delivered["message_subject"], message_text = message_delivered["message_body"])
	
	confirmation_email = ConfirmationEmail(sent_message)
	confirmation_email.create_confirmation_text()
	
	confirmation_email.send_confirmation_email()
 
# then finally, mark those as confirmed in our database

cq.markAsConfirmed(conn, unconfirmed.keys())
</code></pre>

<p>And that’s it. We’ve built out a confirmation email system using Python - not very pretty, but it sure knows how to get the job done. Our final task is to run this puppy on a schedule using cron:</p>

<p><code>$ env EDITOR=nano crontab -e</code></p>

<p><code>
*/3 * * * * /path/to/your/script
</code></p>

<p>That will set up a cron job that runs every 3 minutes and executes our confirmation email script. We’re ready to run this live, and – barring anything catastrophic like a server crash – it’s relatively error proof. The script is designed to just fail silently and re-open every session if a script can’t finish execution, so if a script misfires we’ll just pick up those confirmation emails in the next batch three minutes later.</p>

<p>I’m a Mailgun convert after this. It’s perfect for setting up simple email messages and automating them. The fact that I hacked this together in a few hours with most of that time dedicated to parsing through Engage’s API documentation shows the ease of Mailgun’s system. I’m all for it.</p>

		<a class="twitter-share-button" href="http://twitter.com/share" data-url="http://josephmosby.com/2014/04/03/hacking-confirmation-emails-on-the-fly-with-mailgun.html" data-via="josephmosby">Tweet</a>
	</div>
</div>
			</div>
		</div>

		<div class="wrapper" id="footer">
			<div class="container">
				<div class="row">
					<div class="col-13">
						<p>Brought to you live from Washington, D.C.</p>
					</div>
				</div>
			</div>
		</div>

		<script src="app.js"></script>

		<script>
	
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-45638065-1', 'josephmosby.com');
	    ga('send', 'pageview');
	  
	  	</script>

  		<script>
		window.twttr=(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return;js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);t._e=[];t.ready=function(f){t._e.push(f);};return t;}(document,"script","twitter-wjs"));
		</script>

	</body>

</html>