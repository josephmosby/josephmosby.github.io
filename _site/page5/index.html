<!doctype html>
<html>
	<head>

		<title>josephmosby.com</title>
		<meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
		<link rel="stylesheet" href="/css/main.css" />

	</head>
	
	<body>
		
		<nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
			<a class="navbar-brand" href="/">JM</a>
			<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
				<span class="navbar-toggler-icon"></span>
			</button>

			<div id="navbarCollapse" class="collapse navbar-collapse">
				<ul class="navbar-nav mr-auto">
					<li class="nav-item"><a href="/archives">Archives</a></li>
					<li class="nav-item"><a href="/about">About</a></li>
					<li class="nav-item"><a href="/presentations">Presentations</a></li>
					<li class="nav-item"><a href="/feed/atom.xml">RSS</a></li>
				</ul>
			</div>
		</nav>
		
		<main class="container home" role="main">
			
<div class="row">
	<div class="col-md-4 col-sm-12">
		<div class="post-fm"><time>19 Oct 2015</time>
			<a href="/tags/">code</a>
		</div>
		<h3>Debugging uWSGI dropouts</h3>

	</div>
	<div class="col-md-8 col-sm-12">
		<p>On Friday night, our National Journal app suddenly stopped responding to requests. Our response time went straight through the roof, but this didn’t correspond to any noticeable increase in load. In fact, our throughput (the requests per minute we respond to) had been declining up until the breakdown. We didn’t have any noticeable spike in traffic that corresponded to this outage, so I suspect our <code class="highlighter-rouge">uwsgi</code> configuration may be to blame. Here’s what the graph looked like:</p>

<p><img src="/images/errors.png" alt="" /></p>

<p>I’m going to tear through the <code class="highlighter-rouge">uwsgi</code> logs today to see if I can nail down the culprit. If my <code class="highlighter-rouge">uwsgi</code> threads are dying and not coming back, I’d expect to see a message like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker 1 killed successfully (pid: 17421)
</code></pre></div></div>

<p>that wasn’t accompanied with a message like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Respawned uWSGI worker 1 (new pid: 9438)
</code></pre></div></div>

<p>I’ve pulled the log files down from one of our application servers and will be going through it. I want to start by culling things down to only things that occurred in that 5:00-5:45 timeframe, so let’s whittle it down with some <code class="highlighter-rouge">grep</code>. I’ll use the <code class="highlighter-rouge">-m 1</code> flag to call only the first occurrence and the <code class="highlighter-rouge">-n</code> flag to show the line number.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ grep -m 1 -n "Oct 16 17:00:00" django-www.log

763413:{address space usage: 3525341184 bytes/3362MB} {rss usage: 135106560 bytes/128MB} [pid: 2449|app: 0|req: 1197/17093] [IP ADDRESS] () {42 vars in 736 bytes} [Fri Oct 16 17:00:00 2015] GET /s/54699/1-easy-way-donald-trump-could-have-been-even-richer-doing-nothing =&gt; generated 304819 bytes in 178 msecs (HTTP/1.1 200) 5 headers in 263 bytes (6 switches on core 96)

$ grep -m 1 -n "Oct 16 17:45:00" django-www.log
 
768139:{address space usage: 3510857728 bytes/3348MB} {rss usage: 103940096 bytes/99MB} [pid: 11399|app: 0|req: 174/680] [IP ADDRESS] () {48 vars in 919 bytes} [Fri Oct 16 17:45:00 2015] GET /energy/scientists-go-beyond-science-to-explain-their-climate-terror-20140826?ref=facebook.com =&gt; generated 0 bytes in 31 msecs (HTTP/1.1 302) 3 headers in 226 bytes (1 switches on core 143)
</code></pre></div></div>

<p>Now I’m going to use <code class="highlighter-rouge">sed</code> to create a new file of only that range of lines from 763413 to 768139, to make parsing faster and easier. I’ll drop this output into a new file called <code class="highlighter-rouge">outage.log</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sed -n 763413,768139p django-www.log &gt; outage.log
</code></pre></div></div>

<p>Okay, now that I’ve whittled things down, I want to look for things indicating my workers died:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ grep -n "killed successfully" outage.log
$ grep -n "Seeya" outage.log
</code></pre></div></div>

<p>Both of those didn’t yield anything. Let’s maybe instead look for signs of spawning:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ grep -n "spawn" outage.log

999:DAMN ! worker 1 (pid: 2449) died, killed by signal 9 :( trying respawn ...
1000:Respawned uWSGI worker 1 (new pid: 8359)
1862:Fri Oct 16 17:28:18 2015 - HARAKIRI [core 151] [IP ADDRESS] - GET /member/energy/n2k-energy-solyndra-spawns-calls-for-more-probes-dems-ask-obama-to-hold-off-on-keystone-20111027 since 1445030637
1882:Fri Oct 16 17:28:18 2015 - HARAKIRI [core 171] [IP ADDRESS] - GET /member/energy/n2k-energy-solyndra-spawns-calls-for-more-probes-dems-ask-obama-to-hold-off-on-keystone-20111027 since 1445030802
1972:DAMN ! worker 3 (pid: 2977) died, killed by signal 9 :( trying respawn ...
1973:Respawned uWSGI worker 3 (new pid: 9731)
2324:DAMN ! worker 2 (pid: 2712) died, killed by signal 9 :( trying respawn ...
2325:Respawned uWSGI worker 2 (new pid: 10063)
2601:DAMN ! worker 4 (pid: 3240) died, killed by signal 9 :( trying respawn ...
2602:Respawned uWSGI worker 4 (new pid: 10065)
3006:DAMN ! worker 1 (pid: 8359) died, killed by signal 9 :( trying respawn ...
3007:Respawned uWSGI worker 1 (new pid: 10593)
4025:spawned uWSGI master process (pid: 11394)
4026:spawned uWSGI worker 1 (pid: 11397, cores: 256)
4027:spawned uWSGI worker 2 (pid: 11398, cores: 256)
4029:spawned uWSGI worker 3 (pid: 11399, cores: 256)
4030:spawned uWSGI worker 4 (pid: 11400, cores: 256)
</code></pre></div></div>

<p>NOW we’re cooking. I’m going to chop things up a little bit more, since I can tell from this that we rebooted the app at line 4025.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sed -n 1,4030p outage.log &gt; outage2.log &amp;&amp; mv outage2.log outage.log
</code></pre></div></div>

<p>And now let’s look for something weird. I’m going to just dump out some of the things I’ve looked for.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ grep -n "17:23" outage.log
$ grep -n "HARAKIRI" outage.log
$ grep -n "spawn" outage.log
</code></pre></div></div>

<p>Then I came back to this and scrolled back up through the files:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ grep -n "17:23" outage.log

1393:Fri Oct 16 17:23:00 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1395:Fri Oct 16 17:23:00 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1401:Fri Oct 16 17:23:08 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1404:Fri Oct 16 17:23:10 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1408:Fri Oct 16 17:23:15 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1409:Fri Oct 16 17:23:15 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1414:Fri Oct 16 17:23:16 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1417:Fri Oct 16 17:23:17 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1421:Fri Oct 16 17:23:20 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1424:Fri Oct 16 17:23:21 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1432:Fri Oct 16 17:23:32 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
1436:Fri Oct 16 17:23:38 2015 - uwsgi_response_write_body_do(): Broken pipe [core/writer.c line 331] during GET 
</code></pre></div></div>

<p>That maps <em>exactly</em> back to the time that our application started spiking. I think I may have a breadcrumb.</p>

<p>… goes to Google …</p>

<p>Maybe not. <code class="highlighter-rouge">uwsgi</code> throws out those broken pipe errors in the instance of a timeout, and it would make sense that things would be timing out around that time.</p>

<p>But what a second. I’m going to scroll up the log files until a few minutes <em>before</em> the crash starts acting up to see if I can pinpoint what went wrong. Here’s a sample line from that timeframe:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{address space usage: 3521130496 bytes/3358MB} {rss usage: 167030784 bytes/159MB} [pid: 2712|app: 0|req: 1548/18272] [IP ADDRESS] () {40 vars in 668 bytes} [Fri Oct 16 17:17:50 2015] GET /columns/political-connections =&gt; generated 58615 bytes in 18558 msecs (HTTP/1.1 404) 2 headers in 95 bytes (2 switches on core 16)
</code></pre></div></div>

<p>That took us 18.5 seconds to generate a 404 page for a broken link. That’s absurd. Right around the time that I read this line, one of our system administrators (who I’ve been live-updating as I worked) comes running around the corner to say:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; we didn't have uwsgi timeouts set on nginx!
</code></pre></div></div>

<p>Ahh. So <code class="highlighter-rouge">nginx</code> was timing out on sending and receiving data to and from <code class="highlighter-rouge">uwsgi</code>, but weren’t <em>actually</em> timing out. We were just letting <code class="highlighter-rouge">uwsgi</code> spin into infinity. We fix that with these lines in our <code class="highlighter-rouge">nginx.conf</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>location / {
	... stuff ...
	uwsgi_read_timeout 300;
    uwsgi_send_timeout 300;
    ... stuff ...
}
</code></pre></div></div>

<p>We think that might be our ticket, allowing these dropped connections to actually timeout. We’ll need a few days in production before I give the all-clear, but I think that might do it!</p>

	</div>

</div>

<div class="row">
	<div class="col-md-4 col-sm-12">
		<div class="post-fm"><time>17 Oct 2015</time>
			<a href="/tags/">code</a>
		</div>
		<h3>What does systemd do?</h3>

	</div>
	<div class="col-md-8 col-sm-12">
		<p>I mentioned in an <a href="http://josephmosby.com/2015/10/17/what-does-systemctl-do.html">earlier post</a> that <code class="highlighter-rouge">systemctl</code> appeared to be tied to <code class="highlighter-rouge">systemd</code>, which looked like a much more important program. In this post, I’m going to explore <code class="highlighter-rouge">systemd</code> and see what it does.</p>

<p>Turns out, it does a LOT. And people are super unhappy about it.</p>

<p>I loosely knew the Unix philosophy, which essentially states that programs should be tiny and do very little, rather than one program taking on monolithic functionality. Doug McIlroy, a former head of the Bell Labs Computing Sciences Research Center, summarized it thus:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.
</code></pre></div></div>

<p><code class="highlighter-rouge">systemd</code> does way more than this. It does a bajillion things, and it does them well, but it still does a bajillion things rather than just one.</p>

<p>At its core, <code class="highlighter-rouge">systemd</code> is a Linux init system. It’s designed to kick off programs - every single program that runs on a Unix system. As such, it’s the first process spawned when a system boots:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ps -ef | grep "systemd"
root         1     0  0 00:40 ?        00:00:04 /usr/lib/systemd/systemd --system --deserialize 21
root      1636     1  0 00:40 ?        00:00:00 /usr/lib/systemd/systemd-journald
root      1649     1  0 00:40 ?        00:00:00 /usr/lib/systemd/systemd-udevd
dbus      2488     1  0 00:40 ?        00:00:01 /bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation
root      2490     1  0 00:40 ?        00:00:00 /usr/lib/systemd/systemd-logind
root     15732 15713  0 16:36 pts/3    00:00:00 grep --color=auto systemd
</code></pre></div></div>

<p>PID 1! The maker of all other services in a Unix operating system! I never knew what PID 1 would be, but there it is: <code class="highlighter-rouge">systemd</code>. This post is going to be heavy, I think. And I’ll probably leave myself asking more questions. I’m not really grokking anything in-depth from the <a href="https://en.wikipedia.org/wiki/Systemd">Wikipedia page</a> for <code class="highlighter-rouge">systemd</code>, so off I go to the <a href="http://www.freedesktop.org/software/systemd/man/systemd.html">man pages</a>.</p>

<p><code class="highlighter-rouge">systemd</code> has an entire “Concepts” page devoted to it, which is extremely useful. It states that <code class="highlighter-rouge">systemd</code> has a concept of units - our services, sockets, and other objects we used earlier. <code class="highlighter-rouge">nginx</code> is a unit. <code class="highlighter-rouge">dashboard</code> is a unit. Now we get some meat about what those units can be, and I’m just going to copy and paste the list here.</p>

<ol>
  <li>
    <p>Service units, which start and control daemons and the processes they consist of.</p>
  </li>
  <li>
    <p>Socket units, which encapsulate local IPC or network sockets in the system, useful for socket-based activation.</p>
  </li>
  <li>
    <p>Target units are useful to group units, or provide well-known synchronization points during boot-up.</p>
  </li>
  <li>
    <p>Device units expose kernel devices in systemd and may be used to implement device-based activation.</p>
  </li>
  <li>
    <p>Mount units control mount points in the file system.</p>
  </li>
  <li>
    <p>Automount units provide automount capabilities, for on-demand mounting of file systems as well as parallelized boot-up.</p>
  </li>
  <li>
    <p>Snapshot units can be used to temporarily save the state of the set of systemd units, which later may be restored by activating the saved snapshot unit.</p>
  </li>
  <li>
    <p>Timer units are useful for triggering activation of other units based on timers.</p>
  </li>
  <li>
    <p>Swap units are very similar to mount units and encapsulate memory swap partitions or files of the operating system.</p>
  </li>
  <li>
    <p>Path units may be used to activate other services when file system objects change or are modified.</p>
  </li>
  <li>
    <p>Slice units may be used to group units which manage system processes (such as service and scope units) in a hierarchical tree for resource management purposes.</p>
  </li>
  <li>
    <p>Scope units are similar to service units, but manage foreign processes instead of starting them as well.</p>
  </li>
</ol>

<p>I still don’t know what a target unit is, so I’m going to move into the man page for <code class="highlighter-rouge">systemd.target</code> for a moment. This line is helpful from those pages: “They exist merely to group units via dependencies (useful as boot targets), and to establish standardized names for synchronization points used in dependencies between units.” I think I’ve got it now - if you want to smash together a bunch of units into one (like you’d need to do for a multi-user system), you use a target unit.</p>

<p><code class="highlighter-rouge">systemd</code> also manages the dependencies of units, and that’s where those <code class="highlighter-rouge">Requires</code>, <code class="highlighter-rouge">Conflicts</code>, <code class="highlighter-rouge">After</code>, and <code class="highlighter-rouge">Before</code> lines came into play earlier. From my dashboard service’s <code class="highlighter-rouge">systemctl show</code> output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Requires=basic.target
Wants=system.slice
WantedBy=multi-user.target
Conflicts=shutdown.target
Before=shutdown.target multi-user.target
After=network.target systemd-journald.socket basic.target system.slice
</code></pre></div></div>

<p>My service Requires <code class="highlighter-rouge">basic.target</code>, Conflicts with <code class="highlighter-rouge">shutdown.target</code>, must be before <code class="highlighter-rouge">shutdown.target</code> and <code class="highlighter-rouge">multi-user.target</code>, and must come after <code class="highlighter-rouge">network.target</code>, <code class="highlighter-rouge">systemd-journald.socket</code>, <code class="highlighter-rouge">basic.target</code>, and <code class="highlighter-rouge">system.slice</code>. I’m not sure what most of these mean, but it does make sense that my web program should be loaded after the <code class="highlighter-rouge">network</code> has been loaded.</p>

<p><code class="highlighter-rouge">systemd</code> states that it loads information about unit configuration from system directories and user directories, which I can find by typing the following commands in:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ pkg-config systemd --variable=systemdsystemunitdir
/usr/lib/systemd/system

$ pkg-config systemd --variable=systemduserunitdir
/usr/lib/systemd/user
</code></pre></div></div>

<p>Let’s go see what’s in those:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /usr/lib/systemd/system
$ ls
</code></pre></div></div>

<p>Ooh, I see a bunch of files that look like the <code class="highlighter-rouge">.service</code> files I was tinkering around with last night but didn’t understand! Let’s inspect a few.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat sound.target
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Sound Card
Documentation=man:systemd.special(7)
StopWhenUnneeded=yes

$ cat halt.target
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Halt
Documentation=man:systemd.special(7)
DefaultDependencies=no
Requires=systemd-halt.service
After=systemd-halt.service
AllowIsolate=yes

[Install]
Alias=ctrl-alt-del.target

$ cat crond.service
[Unit]
Description=Command Scheduler
After=syslog.target auditd.service systemd-user-sessions.service time-sync.target

[Service]
EnvironmentFile=/etc/sysconfig/crond
ExecStart=/usr/sbin/crond -n $CRONDARGS
KillMode=process

[Install]
WantedBy=multi-user.target
</code></pre></div></div>

<p>So these <code class="highlighter-rouge">.service</code> and <code class="highlighter-rouge">.target</code> files are all part of the configuration that <code class="highlighter-rouge">systemd</code> requires. The <code class="highlighter-rouge">crond.service</code> configuration isn’t <code class="highlighter-rouge">crond</code> itself, it’s a file that tells <code class="highlighter-rouge">systemd</code> how to start and manage <code class="highlighter-rouge">crond</code>. I’m getting it now!</p>

<p><code class="highlighter-rouge">systemd</code> can also receive certain signals, such as <code class="highlighter-rouge">SIGTERM</code>, <code class="highlighter-rouge">SIGINT</code>, and <code class="highlighter-rouge">SIGRTMIN+15</code>, which are more black magic to me. I’m not sure how I would send those signals to <code class="highlighter-rouge">systemd</code>, but maybe those things aren’t for me in the way I think of them.</p>

<p>I think that’s a good start into <code class="highlighter-rouge">systemd</code>, but I can tell I’m just scratching the surface with it. Next up: this <a href="http://0pointer.de/blog/projects/systemd.html">blog post</a> on the origins of <code class="highlighter-rouge">systemd</code> and the <code class="highlighter-rouge">systemd</code> <a href="http://www.freedesktop.org/wiki/Software/systemd/">homepage</a>.</p>

	</div>

</div>

<div class="row">
	<div class="col-md-4 col-sm-12">
		<div class="post-fm"><time>17 Oct 2015</time>
			<a href="/tags/">code</a>
		</div>
		<h3>What does systemctl do?</h3>

	</div>
	<div class="col-md-8 col-sm-12">
		<p>In my <a href="http://josephmosby.com/2015/10/16/up-and-running-with-flask-on-a-brand-new-linode.html">earlier post</a> on nginx and uWSGI, I used <code class="highlighter-rouge">systemctl</code> to kick off my app. I admittedly don’t know much about systemctl (or about CentOS, if we’re being totally honest), so I wanted to dig more into that.</p>

<p>My first round of looking for documentation took me to the Fedora project’s <a href="https://docs.fedoraproject.org/en-US/Fedora/15/html/Deployment_Guide/ch-Services_and_Daemons.html">documentation on services and daemons</a>. (Turns out that <a href="https://danielmiessler.com/study/fedora_redhat_centos/">CentOS is ultimately a fork of Fedora</a>) The official documentation seems like a good place to start here. It gives a nice description of how to check the status of my service, so I’m going to do that here.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl status dashboard.service
dashboard.service - uwsgi instance to serve dashboard
   Loaded: loaded (/etc/systemd/system/dashboard.service; enabled)
   Active: active (running) since Sat 2015-10-17 04:32:57 UTC; 10h ago
 Main PID: 14914 (uwsgi)
   CGroup: /system.slice/dashboard.service
           ├─14914 /var/www/dashboard/venv/bin/uwsgi --ini dashboard.ini
           ├─14916 /var/www/dashboard/venv/bin/uwsgi --ini dashboard.ini
           ├─14917 /var/www/dashboard/venv/bin/uwsgi --ini dashboard.ini
           ├─14918 /var/www/dashboard/venv/bin/uwsgi --ini dashboard.ini
           ├─14919 /var/www/dashboard/venv/bin/uwsgi --ini dashboard.ini
           └─14920 /var/www/dashboard/venv/bin/uwsgi --ini dashboard.ini

Oct 17 04:32:57 [INFO ABOUT MY LINODE] uwsgi[14914]: spawned uWSGI worker 5 (pid: 14920, cores: 1)
Oct 17 04:33:00 [INFO ABOUT MY LINODE] uwsgi[14914]: [pid: 14920|app: 0|req: 1/1] [WHAT LOOKS LIKE AN IP ADDRESS] () {42 vars in 722 b...re 0)
Oct 17 04:33:00 [INFO ABOUT MY LINODE] uwsgi[14914]: [pid: 14919|app: 0|req: 1/2] [WHAT LOOKS LIKE AN IP ADDRESS] () {42 vars in 713 b...re 0)
Oct 17 04:33:00 [INFO ABOUT MY LINODE] uwsgi[14914]: [pid: 14920|app: 0|req: 2/3] [WHAT LOOKS LIKE AN IP ADDRESS] () {42 vars in 680 b...re 0)
Oct 17 04:35:56 [INFO ABOUT MY LINODE] uwsgi[14914]: [pid: 14920|app: 0|req: 3/4] [WHAT LOOKS LIKE AN IP ADDRESS] () {42 vars in 722 b...re 0)
Oct 17 04:35:56 [INFO ABOUT MY LINODE] uwsgi[14914]: [pid: 14916|app: 0|req: 1/5] [WHAT LOOKS LIKE AN IP ADDRESS] () {42 vars in 713 b...re 0)
Oct 17 04:35:59 [INFO ABOUT MY LINODE] uwsgi[14914]: [pid: 14920|app: 0|req: 4/6] [WHAT LOOKS LIKE AN IP ADDRESS] () {42 vars in 680 b...re 0)
Oct 17 04:37:15 [INFO ABOUT MY LINODE] uwsgi[14914]: [pid: 14920|app: 0|req: 5/7] [WHAT LOOKS LIKE AN IP ADDRESS] () {42 vars in 722 b...re 0)
Oct 17 04:37:16 [INFO ABOUT MY LINODE] uwsgi[14914]: [pid: 14919|app: 0|req: 2/8] [WHAT LOOKS LIKE AN IP ADDRESS] () {42 vars in 713 b...re 0)
Oct 17 04:37:16 [INFO ABOUT MY LINODE] uwsgi[14914]: [pid: 14916|app: 0|req: 2/9] [WHAT LOOKS LIKE AN IP ADDRESS] () {42 vars in 680 b...re 0)
Hint: Some lines were ellipsized, use -l to show in full.
</code></pre></div></div>

<p>I masked out what I think would be identifying details that I don’t want out there. The first commented-out section was my Linode’s name, but the second was an IP address that I did not recognize. Maybe it’s my IPv4 address? Maybe it’s the Linode’s hypervisor IP address? I think, though, that these logs may be from uWSGI and not from <code class="highlighter-rouge">systemctl</code>. I say this because the Fedora documentation doesn’t have anything that looks like this in their <a href="https://docs.fedoraproject.org/en-US/Fedora/15/html/Deployment_Guide/s1-services-running.html">page about these logs</a>. I’m going to skip it for now. Most of the other information on Fedora’s page here is about using the tool, which I’ve already done, so I’m going to move on to the raw man pages.</p>

<p>The man page for <code class="highlighter-rouge">systemctl</code> gives the following description for its use:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl — Control the systemd system and service manager
</code></pre></div></div>

<p>Okay, so <code class="highlighter-rouge">systemctl</code> is actually used to control the <code class="highlighter-rouge">systemd</code> tool. Maybe the documentation was a little sparse because <code class="highlighter-rouge">systemd</code> is where the money is. Still, let’s go through the <a href="http://www.freedesktop.org/software/systemd/man/systemctl.html">man page</a> to see what we can get here. I’m going to punch through the commands one by one to walk through what they can do.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl -t
systemctl: option requires an argument -- 't'
</code></pre></div></div>

<p>Mer, that didn’t go well. I didn’t read the documentation enough. It requires a listing of unit types, which I can find here:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl -t help
Available unit types:
service
socket
target
device
mount
automount
snapshot
timer
swap
path
slice
scope

$ systemctl -t service

UNIT                               LOAD   ACTIVE SUB     DESCRIPTION
.... stuff ...
crond.service                      loaded active running Command Scheduler
dashboard.service                  loaded active running uwsgi instance to serve dashboard
dbus.service                       loaded active running D-Bus System Message Bus
.... stuff ...
</code></pre></div></div>

<p>Aha! There’s my <code class="highlighter-rouge">dashboard</code> service, sandwiched right in between cron and something called <code class="highlighter-rouge">dbus</code>. It looks like it’s loaded, active, and running, which is what I would expect. <code class="highlighter-rouge">$ systemctl --state=active</code> provides the same information, just a different way to cut the data.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl -t service --recursive
</code></pre></div></div>

<p>This doesn’t work as expected on my machine. It may be live on Fedora, but disabled on CentOS or something like that.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl -t service --reverse
</code></pre></div></div>

<p>The man page says this should do the following: “Show reverse dependencies between units with list-dependencies, i.e. follow dependencies of type WantedBy=, RequiredBy=, RequiredByOverridable=, PartOf=, BoundBy=, instead of Wants= and similar.” I remember having to type <code class="highlighter-rouge">WantedBy=</code> in my configuration earlier:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ vi /etc/systemd/system/dashboard.service

[Unit]
Description=uwsgi instance to serve dashboard
After=network.target

[Service]
User=ghost
Group=nginx
WorkingDirectory=/var/www/dashboard
Environment="PATH=/var/www/dashboard/venv/bin"
ExecStart=/var/www/dashboard/venv/bin/uwsgi --ini dashboard.ini

[Install]
WantedBy=multi-user.target
</code></pre></div></div>

<p>Okay, so I must have configured <code class="highlighter-rouge">dashboard.service</code> to start with some sort of a dependency: this <code class="highlighter-rouge">multi-user.target</code> thing. Let’s see if I can find that.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl -t target

UNIT                LOAD   ACTIVE SUB    DESCRIPTION
... stuff ...
local-fs.target     loaded active active Local File Systems
multi-user.target   loaded active active Multi-User System
network.target      loaded active active Network
... stuff ...
</code></pre></div></div>

<p>It looks like these “targets” are super important. I didn’t know you could even have a Unix system without multiple users, but it looks like that’s something you have to manually turn on - and can turn off. Crazy.</p>

<p>There are two commands here that I don’t want to fiddle with too much for now, because I plan to go down a <code class="highlighter-rouge">systemd</code> rabbit hole and these look like I could cause problems if I don’t know what I’m doing. I’ll circle back to them.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl --job-mode= ? 
$ systemctl --fail 
</code></pre></div></div>

<p>The rest of the options here look like they’re tied to actually starting and stopping services, rather than just managing them. Rather than try to imply what’s going on with these, I want to jump down to the Commands section so I can start understanding what this utility can do.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl list-units
</code></pre></div></div>

<p>This does the same thing as just typing <code class="highlighter-rouge">systemctl</code>, and it dumps out an unfiltered list of running services and sockets and things.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl start [SOMETHING]
$ systemctl stop [SOMETHING]
$ systemctl restart [SOMETHING]
</code></pre></div></div>

<p>I used these last night, and they do exactly what I’d expect. They start, stop, and restart services. This one’s new though:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl reload [SOMETHING]
</code></pre></div></div>

<p>When we type this, we can reload the configuration of a service without actually reloading the service itself. We could reload <code class="highlighter-rouge">nginx.conf</code> by typing <code class="highlighter-rouge">systemctl reload nginx</code>.</p>

<p>Now for what is the unexpectedly big kahuna:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl show dashboard

Id=dashboard.service
Names=dashboard.service
Requires=basic.target
Wants=system.slice
WantedBy=multi-user.target
Conflicts=shutdown.target
Before=shutdown.target multi-user.target
After=network.target systemd-journald.socket basic.target system.slice
Description=uwsgi instance to serve dashboard
LoadState=loaded
ActiveState=active
SubState=running
FragmentPath=/etc/systemd/system/dashboard.service
UnitFileState=enabled
InactiveExitTimestamp=Sat 2015-10-17 04:32:57 UTC
InactiveExitTimestampMonotonic=13928551290
ActiveEnterTimestamp=Sat 2015-10-17 04:32:57 UTC
ActiveEnterTimestampMonotonic=13928551290
ActiveExitTimestamp=Sat 2015-10-17 04:31:52 UTC
ActiveExitTimestampMonotonic=13863477373
InactiveEnterTimestamp=Sat 2015-10-17 04:31:52 UTC
InactiveEnterTimestampMonotonic=13863477373
CanStart=yes
CanStop=yes
CanReload=no
CanIsolate=no
StopWhenUnneeded=no
RefuseManualStart=no
RefuseManualStop=no
AllowIsolate=no
DefaultDependencies=yes
OnFailureIsolate=no
IgnoreOnIsolate=no
IgnoreOnSnapshot=no
NeedDaemonReload=no
JobTimeoutUSec=0
ConditionTimestamp=Sat 2015-10-17 04:32:57 UTC
ConditionTimestampMonotonic=13928549499
ConditionResult=yes
Transient=no
Slice=system.slice
ControlGroup=/system.slice/dashboard.service
Type=simple
Restart=no
NotifyAccess=none
RestartUSec=100ms
TimeoutStartUSec=1min 30s
TimeoutStopUSec=1min 30s
WatchdogUSec=0
WatchdogTimestampMonotonic=0
StartLimitInterval=10000000
StartLimitBurst=5
StartLimitAction=none
ExecStart={ path=/var/www/dashboard/venv/bin/uwsgi ; argv[]=/var/www/dashboard/venv/bin/uwsgi --ini dashboard.ini ; ignore_errors=no ; start_time=[Sat 2
PermissionsStartOnly=no
RootDirectoryStartOnly=no
RemainAfterExit=no
GuessMainPID=yes
MainPID=14914
ControlPID=0
Result=success
Environment=PATH=/var/www/dashboard/venv/bin
UMask=0022
LimitCPU=18446744073709551615
LimitFSIZE=18446744073709551615
LimitDATA=18446744073709551615
LimitSTACK=18446744073709551615
LimitCORE=18446744073709551615
LimitRSS=18446744073709551615
LimitNOFILE=4096
LimitAS=18446744073709551615
LimitNPROC=3934
LimitMEMLOCK=65536
LimitLOCKS=18446744073709551615
LimitSIGPENDING=3934
LimitMSGQUEUE=819200
LimitNICE=0
LimitRTPRIO=0
LimitRTTIME=18446744073709551615
WorkingDirectory=/var/www/dashboard
OOMScoreAdjust=0
Nice=0
IOScheduling=0
CPUSchedulingPolicy=0
CPUSchedulingPriority=0
TimerSlackNSec=50000
CPUSchedulingResetOnFork=no
NonBlocking=no
StandardInput=null
StandardOutput=journal
StandardError=inherit
TTYReset=no
TTYVHangup=no
TTYVTDisallocate=no
SyslogPriority=30
SyslogLevelPrefix=yes
SecureBits=0
CapabilityBoundingSet=18446744073709551615
User=ghost
Group=nginx
MountFlags=0
PrivateTmp=no
PrivateNetwork=no
SameProcessGroup=no
IgnoreSIGPIPE=yes
NoNewPrivileges=no
KillMode=control-group
KillSignal=15
SendSIGKILL=yes
SendSIGHUP=no
CPUAccounting=no
CPUShares=1024
BlockIOAccounting=no
BlockIOWeight=1000
MemoryAccounting=no
MemoryLimit=18446744073709551615
DevicePolicy=auto
ExecMainStartTimestamp=Sat 2015-10-17 04:32:57 UTC
ExecMainStartTimestampMonotonic=13928551199
ExecMainExitTimestampMonotonic=0
ExecMainPID=14914
ExecMainCode=0
ExecMainStatus=0
</code></pre></div></div>

<p>I KNOW WHAT LIKE A TENTH OF THIS MEANS. THIS IS AWESOME.</p>

<p>I’m going to take a break here and digest some of the information gleaned from this little exercise. More to come!</p>

	</div>

</div>

<div class="row">
	<div class="col-md-4 col-sm-12">
		<div class="post-fm"><time>17 Oct 2015</time>
			<a href="/tags/">code</a>
		</div>
		<h3>How are PIDs assigned?</h3>

	</div>
	<div class="col-md-8 col-sm-12">
		<p>I want to take a moment to step through the <code class="highlighter-rouge">ps</code> command and how PIDs are assigned, because I want to walk through the first 10 processes kicked off when CentOS boots. I assume that PIDs are assigned based on the order in which they’re created, but I’m not 100% certain on that. Let’s take a look.</p>

<p>Wikipedia states:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In Unix-like operating systems, new processes are created by the fork() system call. ... Process ID 1 is usually the init process primarily responsible for starting and shutting down the system. ... Process IDs are usually allocated on a sequential basis, beginning at 0 and rising to a maximum value which varies from system to system.
</code></pre></div></div>

<p>So PID 1, our <code class="highlighter-rouge">systemd</code> process, is created first (though there’s a PID 0 which comes before), and all of the other processes follow sequentially. This makes things easier, as now I can (hopefully) get a listing of the first ten things CentOS does on boot. I wasn’t looking for anything more formal than this, so let’s move on.</p>

<p>I don’t quite know how to get information on a specific process by giving its ID, so let’s just try something out:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ps 1
PID TTY      STAT   TIME COMMAND
1 	?        Ss     0:04 /usr/lib/systemd/systemd --system --deserialize 21
</code></pre></div></div>

<p>That was simple enough. There’s <code class="highlighter-rouge">systemd</code>, just as I expected. Let’s look at some others.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ps 2
PID TTY      STAT   TIME COMMAND
2 	?        S      0:00 [kthreadd]

$ ps 3
PID TTY      STAT   TIME COMMAND
3 	?        S      0:00 [ksoftirqd/0]

$ ps 4
# BLANK

$ ps 5
PID TTY      STAT   TIME COMMAND
5 	?        S&lt;     0:00 [kworker/0:0H]

$ ps 6
PID TTY      STAT   TIME COMMAND
6 	?        S      0:00 [kworker/u2:0]

$ ps 7
PID TTY      STAT   TIME COMMAND
7 	?        S      0:00 [rcu_sched]

$ ps 8
PID TTY      STAT   TIME COMMAND
8 	?        S      0:00 [rcu_bh]

$ ps 9
PID TTY      STAT   TIME COMMAND
9 	?        S      0:00 [migration/0]

$ ps 10
PID TTY      STAT   TIME COMMAND
   	10 	?        S&lt;     0:00 [khelper]
</code></pre></div></div>

<p>Well, I couldn’t get 10 commands (#4 was out), but I did get 9:</p>

<ol>
  <li><code class="highlighter-rouge">systemd</code></li>
  <li><code class="highlighter-rouge">kthreadd</code></li>
  <li><code class="highlighter-rouge">ksoftirqd/0</code></li>
  <li><code class="highlighter-rouge">kworker/0:0H</code></li>
  <li><code class="highlighter-rouge">kworker/u2:0</code></li>
  <li><code class="highlighter-rouge">rcu_sched</code></li>
  <li><code class="highlighter-rouge">rcu_bh</code></li>
  <li><code class="highlighter-rouge">migration/0</code></li>
  <li><code class="highlighter-rouge">khelper</code></li>
</ol>

<p>Let’s take a look into what they do to see if they do anything interesting. <code class="highlighter-rouge">systemd</code> we know.</p>

<p><code class="highlighter-rouge">kthreadd</code> is the “kernel thread daemon,” and it’s actually not controlled by <code class="highlighter-rouge">systemd</code>. It’s controlled by the kernel itself. I’m not familiar enough with the kernel (yet) to do any interesting work with this, but I can see from a <code class="highlighter-rouge">ps -ef</code> command that the rest of our listed processes are spawned by this one.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 00:40 ?        00:00:04 /usr/lib/systemd/systemd --system --deserialize 21
root         2     0  0 00:40 ?        00:00:00 [kthreadd]
root         3     2  0 00:40 ?        00:00:00 [ksoftirqd/0]
root         5     2  0 00:40 ?        00:00:00 [kworker/0:0H]
root         6     2  0 00:40 ?        00:00:00 [kworker/u2:0]
root         7     2  0 00:40 ?        00:00:00 [rcu_sched]
root         8     2  0 00:40 ?        00:00:00 [rcu_bh]
root         9     2  0 00:40 ?        00:00:00 [migration/0]
root        10     2  0 00:40 ?        00:00:00 [khelper]
</code></pre></div></div>

<p>That PPID thread - right there in the middle - indicates that each of the following PIDs was spawned by <code class="highlighter-rouge">kthreadd</code>. So we’ll obviously need to come back and explore this one in more detail.</p>

<p>Next on the list is <code class="highlighter-rouge">ksoftirqd</code>, which “is a per-cpu kernel thread that runs when the machine is under heavy soft-interrupt load.” <a href="http://www.ms.sapientia.ro/~lszabo/unix_linux_hejprogramozas/man_en/htmlman9/ksoftirqd.9.html">docs here</a> Again, I’m not 100% certain on how this works, but I’m bookmarking <a href="https://lwn.net/Articles/520076/">this page</a> for future reference.</p>

<p>The next two are inherently related: they’re <code class="highlighter-rouge">kworker</code> kernel processes. They handle work for system calls, rather than user calls.</p>

<p><code class="highlighter-rouge">rcu_sched</code> and <code class="highlighter-rouge">rcu_bh</code> are apparently a bit more arcane, given the lack of easy-to-find information about them. RCU stands for “Read-Copy-Update”, and it’s a synchronization mechanism. I’ll be digging more into this later, but I’m bookmarking <a href="http://lwn.net/Articles/262464/">this article</a> for future reference.</p>

<p>The <code class="highlighter-rouge">migration</code> process is also a kernel process, and it distributes the load across processor cores.</p>

<p>Finally (and perhaps fortuitously) we have <code class="highlighter-rouge">khelper</code>. This process is used to make calls to user processes from within the kernel, allowing the kernel and user processes to talk to each other.</p>

<p>So we’ve got our first ten processes. What does this <code class="highlighter-rouge">ps</code> process output tell us about them? Let’s take a second look at our sample data:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 00:40 ?        00:00:04 /usr/lib/systemd/systemd --system --deserialize 21
</code></pre></div></div>

<p>The first column here is the user who kicked off the process: in this case, it’s the root user. The PID is our process ID, and the PPID is the PID of the parent that spawned the process. C is used for CPU scheduling information. STIME is the time the process started. TTY is the terminal associated with the process. TIME is the CPU time the process has used. And CMD is the command itself. There are loads more options that we could incorporate here, but this is the default configuration for CentOS machines.</p>

<p>I think <code class="highlighter-rouge">ps</code> will need its own set of digging (like many other Unix utilities), so I’m going to stop here. Here are my open questions kicked off from this exercise:</p>

<ol>
  <li>What does the kernel thread daemon do?</li>
  <li>What is a software interrupt?</li>
  <li>What is the read-copy-update mechanism?</li>
</ol>

	</div>

</div>

<div class="row">
	<div class="col-md-4 col-sm-12">
		<div class="post-fm"><time>16 Oct 2015</time>
			<a href="/tags/">code</a>
		</div>
		<h3>Up and Running with Flask on a Brand New Linode</h3>

	</div>
	<div class="col-md-8 col-sm-12">
		<p>Tonight, I’m building a minimalistic Flask app that will run on Linode. Flask is a relatively new framework for me. I’ve dealt with CentOS, nginx, and uwsgi at work, but I’ve never tried to get them installed on my own. Time to get started.</p>

<h3 id="step-1-install-and-configure-nginx-round-1">Step 1: Install and configure nginx, round 1</h3>

<p>I am skipping over the step where we create a CentOS 7 machine from the Linode dashboard. I can’t think of a good way to explain that one without screenshots. Let’s assume we have one, and let’s install the necessaries on it.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ yum install epel-release
$ yum install nginx
</code></pre></div></div>

<p>Okay! That was simple enough. Here we’ve installed nginx, which will allow us to serve up our web pages. I want to start here because I like the feedback of knowing that I’m serving up web pages from the very start.</p>

<p>I know that I plan to serve multiple sites off of this one server, so I need to adjust my domain and nginx configuration accordingly. In Namecheap, I’ve created 2 A records - dashboard.mosby.io and www.mosby.io - which I’ll both point at this server’s IP address. I’ll let nginx sort out the parsing.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/nginx/nginx.conf

... # stuff here that you shouldn't remove

http {

	... # more stuff here that you shouldn't remove

	server { 
		listen	80;
		server_name	www.mosby.io;
		root /var/www/main;
	}

	server {
		listen	80;
		server_name	dashboard.mosby.io;
		root /var/www/dashboard;
	}
}
</code></pre></div></div>

<p>nginx has a configuration file called <code class="highlighter-rouge">nginx.conf</code> that we’re going to modify to serve our sites. Here, we’ve said that any request incoming will either be for <code class="highlighter-rouge">www.mosby.io</code> or <code class="highlighter-rouge">dashboard.mosby.io</code>. If it’s for <code class="highlighter-rouge">www</code>, we’re going to serve content from <code class="highlighter-rouge">/var/www/main</code>. If it’s for <code class="highlighter-rouge">dashboard</code>, we’re going to serve content from <code class="highlighter-rouge">/var/www/dashboard</code>. We can test this out by creating two text files:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /var/www/main/index.html

Hello, www.mosby.io!
</code></pre></div></div>

<p>AND</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /var/www/dashboard/index.html

Hello, dashboard.mosby.io!
</code></pre></div></div>

<p>Assuming that you’ve already pointed your two subdomain to your Linode’s IP address, these will each display their respective content. Success!</p>

<h3 id="step-2-install-python3-flask-and-uwsgi">Step 2: Install Python3, Flask and uWSGI</h3>

<p>This is the part I know least about this entire process. Let’s start by installing Python 3, pip, and a version of <code class="highlighter-rouge">virtualenv</code> that’s cool with all of this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ yum install python34
$ wget https://bootstrap.pypa.io/get-pip.py
$ python3.4 get-pip.py
</code></pre></div></div>

<p>Now I’m going to move into my dashboard folder and create the application.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /var/www/dashboard
$ virtualenv venv
$ source venv/bin/activate
</code></pre></div></div>

<p>We’ve got a local instance of Python3 and pip now. Time to get uWSGI and Flask.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ pip install uwsgi flask
</code></pre></div></div>

<p>Wait hold on. uWSGI just crapped out on installation. I missed something. The scary error message looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Command "/var/www/dashboard/venv/bin/python3.4 -c "import setuptools, tokenize;__file__='/tmp/pip-build-5a_chnf_/uwsgi/setup.py';exec(compile(getattr(tokenize, 'open', open)(__file__).read().replace('\r\n', '\n'), __file__, 'exec'))" install --record /tmp/pip-8zr4gl3_-record/install-record.txt --single-version-externally-managed --compile --install-headers /var/www/dashboard/venv/include/site/python3.4/uwsgi" failed with error code 1 in /tmp/pip-build-5a_chnf_/uwsgi
</code></pre></div></div>

<p>But that’s not the root of the problem. I’ve got to scroll up the stack trace for that.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In file included from plugins/python/python_plugin.c:1:0:
plugins/python/uwsgi_python.h:2:20: fatal error: Python.h: No such file or directory
 #include &lt;Python.h&gt;
</code></pre></div></div>

<p>I don’t have Python headers installed on this system! Let’s see if I can do that.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ yum install python34-devel
$ pip install uwsgi flask
</code></pre></div></div>

<p>Okay, that worked!</p>

<p>And now, let’s convert our little test HTML from before into a Flask app. We’re then going to remove the HTML file, which will let us confirm that we’ve actually set of Flask and uWSGI correctly when we see it again. I’m going to do some work here using the <code class="highlighter-rouge">vi</code> editor, but if you’re not familiar with it, please replace the <code class="highlighter-rouge">vi</code> commands with <code class="highlighter-rouge">nano</code>. It’s simpler.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ vi app.py

from flask import Flask
application = Flask(__name__)

@application.route("/")
def helloworld():
	return "Hello, dashboard.mosby.io on Flask!"

if __name__ == "__main__":
	application.run(host='0.0.0.0')

$ rm index.html
$ python app.py
</code></pre></div></div>

<p>I can see that I’ve done it all right by going to my new homepage in my browser! Visiting dashboard.mosby.io:5000 will show me my updated page.</p>

<h3 id="step-3-configure-uwsgi-serving">Step 3: Configure uWSGI Serving</h3>

<p>We’ve got ourselves a basic skin of an application, so let’s hook it up to nginx through uWSGI.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ uwsgi --socket 0.0.0.0:5000 --protocol=http -w wsgi
</code></pre></div></div>

<p>It works! Exactly the same way it did when we ran the application directly. Let’s build a <code class="highlighter-rouge">.ini</code> file so we can do this more repeatedly.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ vi dashboard.ini

[uwsgi]
module = wsgi

master = true
processes = 5

uid = ghost
socket = dashboard.sock
chown-socket = ghost:nginx
chmod-socket = 660
vacuum = true

die-on-term = true
</code></pre></div></div>

<p>This <code class="highlighter-rouge">ini</code> file does a few things for us. It points to the wsgi module, sets it in master mode, and spawns 5 processes of the app. It also ties to the uWSGI process to a Unix socket, and will remove (vacuum) that socket when the process stops.</p>

<p>I’m also specifying that the <code class="highlighter-rouge">ghost</code> user will own this process. (I’ve been doing all of this work as <code class="highlighter-rouge">root</code>, which is not a good practice for running the application) I now need to create the ghost user and add it to the nginx group.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ useradd ghost
$ usermod -a -G nginx ghost
</code></pre></div></div>

<p>Verify that you did it right:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ id ghost
</code></pre></div></div>

<p>You should see the <code class="highlighter-rouge">ghost</code> user attached to the nginx group. Onward!</p>

<h3 id="step-4-start-on-boot">Step 4: Start on Boot</h3>

<p>When our server comes online, we want our uWSGI app to be available immediately. Let’s start by creating a service file in our <code class="highlighter-rouge">/etc/systemd/system</code> directory.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ vi /etc/systemd/system/dashboard.service

[Unit]
Description=uwsgi instance to serve dashboard
After=network.target

[Service]
User=ghost
Group=nginx
WorkingDirectory=/var/www/dashboard
Environment="PATH=/var/www/dashboard/venv/bin"
ExecStart=/var/www/dashboard/venv/bin/uwsgi --ini dashboard.ini

[Install]
WantedBy=multi-user.target
</code></pre></div></div>

<p>There is black magic going on here that I need to dig into more. I don’t know <em>why</em> we do all of these things, but I do know that we’re specifying the working directory, and the environment, and what should happen when we start things up. Which we’ll do now.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ systemctl start dashboard
$ systemctl enable dashboard
</code></pre></div></div>

<h3 id="step-5-proxy-requests-from-nginx">Step 5: Proxy Requests from Nginx</h3>

<p>Now it’s time that we return to our <code class="highlighter-rouge">nginx.conf</code> file. We need to modify our dashboard server block to handle the uwsgi application.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/nginx/nginx.conf

... # stuff here that you shouldn't remove

http {

	... # more stuff here that you shouldn't remove

	server { 
		listen	80;
		server_name	www.mosby.io;
		root /var/www/main;
	}

	server {
		listen	80;
		server_name	dashboard.mosby.io;
		
		location / {
			include uwsgi_params;
			uwsgi_pass unix:/var/www/dashboard/dashboard.sock;
		}
	}
}

$ nginx -t &lt;-- test your configuration
$ service nginx reload
</code></pre></div></div>

<p>And now we go to our browser and punch in dashboard.mosby.io, and… crap.</p>

<p>502 Bad Gateway. What did I do wrong here? That error means nginx can’t talk to our application.</p>

<p>Ahh, I’ve been doing all this as root. Everything is currently owned by root, which means that neither <code class="highlighter-rouge">ghost</code> nor <code class="highlighter-rouge">nginx</code> can see my dashboard socket. Let’s change that.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ chown ghost:nginx /var/www/dashboard
$ service nginx reload
$ systemctl restart dashboard
</code></pre></div></div>

<p>And, we’re back, folks!</p>

<p>That’s a basic configuration for getting an Flask/uWSGI/nginx app up and running on a CentOS Linode box. If you decide to do something other than CentOS, most of it should still work, but the initialization service script will probably not. You can browse the repository for all of this <a href="https://github.com/josephmosby/dashboard/tree/c776c8875f8eaf094e2c506e1c0aca91693b7323">here</a>.</p>

	</div>

</div>

<div class="row">
	<div class="col-md-4 col-sm-12">
		<div class="post-fm"><time>17 Aug 2015</time>
			<a href="/tags/">presentations</a>
		</div>
		<h3>PyGotham '15 - Building an ALU</h3>

	</div>
	<div class="col-md-8 col-sm-12">
		<p>Really had an awesome time at PyGotham 2015! The organization is phenomenal and really made a fellow East Coaster feel welcome.</p>

<p>Talk is here: <a href="http://www.pyvideo.org/video/3784/modeling-an-arithmetic-logic-unit-in-python">http://www.pyvideo.org/video/3784/modeling-an-arithmetic-logic-unit-in-python</a></p>

<p>And slides are here: <a href="http://josephmosby.com/presentations/pygotham2015">http://josephmosby.com/presentations/pygotham2015</a></p>

<p>Example code is here: <a href="http://josephmosby.com/presentations/pygotham2015/chip_functions.py">http://josephmosby.com/presentations/pygotham2015/chip_functions.py</a></p>

	</div>

</div>

<div class="row">
	<div class="col-md-4 col-sm-12">
		<div class="post-fm"><time>03 Aug 2015</time>
			<a href="/tags/">presentations</a>
		</div>
		<h3>PyOhio '15 - Production Django</h3>

	</div>
	<div class="col-md-8 col-sm-12">
		<p>Over the weekend, I gave a talk at PyOhio 2015 on Production Django applications. Due to the tireless efforts of the video staff, that talk is already available online less than 24 hours later.</p>

<p>Talk is here: <a href="http://www.pyvideo.org/video/3712/production-django-building-a-highly-scalable-se">http://www.pyvideo.org/video/3712/production-django-building-a-highly-scalable-se</a></p>

<p>And slides are here: <a href="http://josephmosby.com/presentations/pyohio2015">http://josephmosby.com/presentations/pyohio2015</a></p>

<p>Special thanks to <a href="http://roberttownley.com/">Robert Townley</a> who gave pre-con feedback and <a href="http://juliangindi.com/">Julian Gindi</a> who gave an earlier talk that inspired some of the material.</p>

	</div>

</div>

<div class="row">
	<div class="col-md-4 col-sm-12">
		<div class="post-fm"><time>18 Jul 2015</time>
			<a href="/tags/">code</a>
		</div>
		<h3>Trusting Python&comma; and the Ken Thompson hack</h3>

	</div>
	<div class="col-md-8 col-sm-12">
		<p>I have always treated Python compilation as a black box. Code goes in, web services come out, everyone is happy. Then I went through <a href="http://www.nand2tetris.org/">NAND2Tetris</a> and picked up a copy of <a href="http://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1437243255&amp;sr=1-1&amp;keywords=the+c+programming+language">The C Programming Language</a>, and it’s been tough to rest as easy ever since.</p>

<p>Python (in its most common derivative, CPython) is not fed straight into a computer’s processor. It’s first “interpreted” into C code, which is then compiled by a C compiler into assembly language, which is then translated into 1’s and 0’s that the computer can actually understand. Let’s take a look at this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print('Hello, world!')
</code></pre></div></div>

<p>That’s the incredibly simple Python code for printing “Hello, world!” Here’s what that looks like in the Python source code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static PyObject *
builtin_print(PyObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"sep", "end", "file", "flush", 0};
    static PyObject *dummy_args;
    PyObject *sep = NULL, *end = NULL, *file = NULL, *flush = NULL;
    int i, err;

    if (dummy_args == NULL &amp;&amp; !(dummy_args = PyTuple_New(0)))
        return NULL;
    if (!PyArg_ParseTupleAndKeywords(dummy_args, kwds, "|OOOO:print",
                                     kwlist, &amp;sep, &amp;end, &amp;file, &amp;flush))
        return NULL;
    if (file == NULL || file == Py_None) {
        file = _PySys_GetObjectId(&amp;PyId_stdout);
        if (file == NULL) {
            PyErr_SetString(PyExc_RuntimeError, "lost sys.stdout");
            return NULL;
        }

        /* sys.stdout may be None when FILE* stdout isn't connected */
        if (file == Py_None)
            Py_RETURN_NONE;
    }

    if (sep == Py_None) {
        sep = NULL;
    }
    else if (sep &amp;&amp; !PyUnicode_Check(sep)) {
        PyErr_Format(PyExc_TypeError,
                     "sep must be None or a string, not %.200s",
                     sep-&gt;ob_type-&gt;tp_name);
        return NULL;
    }
    if (end == Py_None) {
        end = NULL;
    }
    else if (end &amp;&amp; !PyUnicode_Check(end)) {
        PyErr_Format(PyExc_TypeError,
                     "end must be None or a string, not %.200s",
                     end-&gt;ob_type-&gt;tp_name);
        return NULL;
    }

    for (i = 0; i &lt; PyTuple_Size(args); i++) {
        if (i &gt; 0) {
            if (sep == NULL)
                err = PyFile_WriteString(" ", file);
            else
                err = PyFile_WriteObject(sep, file,
                                         Py_PRINT_RAW);
            if (err)
                return NULL;
        }
        err = PyFile_WriteObject(PyTuple_GetItem(args, i), file,
                                 Py_PRINT_RAW);
        if (err)
            return NULL;
    }

    if (end == NULL)
        err = PyFile_WriteString("\n", file);
    else
        err = PyFile_WriteObject(end, file, Py_PRINT_RAW);
    if (err)
        return NULL;

    if (flush != NULL) {
        PyObject *tmp;
        int do_flush = PyObject_IsTrue(flush);
        if (do_flush == -1)
            return NULL;
        else if (do_flush) {
            tmp = _PyObject_CallMethodId(file, &amp;PyId_flush, "");
            if (tmp == NULL)
                return NULL;
            else
                Py_DECREF(tmp);
        }
    }

    Py_RETURN_NONE;
}
</code></pre></div></div>

<p>I understand very little of what’s actually going on here. I do know that ultimately this code has to end up at some sort of terminal output unless I specify otherwise, and I do know that I’ll probably do that by writing to a dedicated terminal output memory location which is probably specified by a C pointer, and this is the extent of my understanding. And we haven’t even made it to assembly code yet. Or to binary instructions.</p>

<p>I go on trusting the CPython interpreter because I have no choice. Perhaps the <code class="highlighter-rouge">PyArg_ParseTupleAndKeywords</code> function has a side effect of batching my printed output up and sending it back to a Python mailing list somewhere, for them to laugh at my coding mistakes. Maybe it’s something more nefarious.</p>

<p>I can look through the CPython source code and see that <code class="highlighter-rouge">PyArg_ParseTupleAndKeywords</code> does exactly what it says it’s going to. But what if the <em>C compiler itself</em> is batching my printed output up and sending it off? In 1984 Ken Thompson described <a href="http://c2.com/cgi/wiki?TheKenThompsonHack">exactly that</a> with a hack that would allow a compiler to do all sorts of terrible things, including overwriting all evidence of its existence. You could detect it, of course, but you’d have to have a trusted compiler - something that most 2015 developers are not prepared to write. (myself included)</p>

<p>And so I have to trust my computer. I have to trust Intel, Apple, all of the component manufacturers, the <code class="highlighter-rouge">gcc</code> team, the CPython team, and everybody in between, because I am not prepared to compute otherwise.</p>

	</div>

</div>

<div class="row">
	<div class="col-md-4 col-sm-12">
		<div class="post-fm"><time>14 Jul 2015</time>
			<a href="/tags/">code</a>
		</div>
		<h3>The uncomfortable reality of software engineering</h3>

	</div>
	<div class="col-md-8 col-sm-12">
		<p>I am haunted by the idea that someone will have to go back and make changes to certain pieces of code that I wrote in the past. The last time that actually happened was on a project that was originally set up as a demo, rife with technical debt as non-technical managers made rapid changes to requirements and promised clients they’d have something to show that same day. Enough of those types of changes and your project suddenly turns into a duck-taped train wreck. No one can read your code and understand how it works, and eventually, you can’t do it either.</p>

<p>I chat with software engineers in all manner of disciplines and this reality is very much the same. Maybe it’s because engineers are working with a management team that doesn’t want to take the time to do things right, but sometimes it’s due to a tired engineer who didn’t sleep well the night before and just wants to find the first fix for a bug that will get him home by 5:30pm. Sometimes it’s more insidious: individually, every feature might have been put into place with proper consideration, but an edge case causes a catastrophic failure once it runs through all of the machinery.</p>

<p>You don’t see that edge case ever properly discussed in the news. It’s too nuanced to make a good story for the general public, and companies are reticent to talk about major problems with their software. Neither <a href="http://www.wired.com/2015/07/united-airlines-flights-grounded-across-us-2nd-time/">United Airlines</a> nor <a href="http://www.wired.com/2015/07/nyse-halts-trading/">NYSE</a> have given any sort of technical reasons for their major glitches last week, but that says a whole lot in and of itself: it wasn’t some sort of concerted cyberterrorist attack, it was just an edge case that finally hit the software where it shouldn’t. Maybe it was just that <a href="http://stackoverflow.com/questions/4456438/how-do-i-correctly-pass-the-string-null-an-employees-proper-surname-to-a-so">Mr. Null</a> booked his first ever United Airlines flight.</p>

<p>Maybe this is all a reality of software engineering and will be forever, but I doubt that. I think we as engineers are approaching our <a href="http://abcnews.go.com/Business/story?id=87293">Arthur Andersen</a> moment. That point where we try to hold our hands up and say that we did what was expected of us and couldn’t possibly do more, but the world will disagree with us. Maybe it’s time we started thinking about how to prevent that moment before it happens because our stakes are much, much higher than the accounting profession’s. No one died because Enron fudged some numbers. They might die if one of those software bugs hits something important: something like an airline.</p>

	</div>

</div>

<div class="row">
	<div class="col-md-4 col-sm-12">
		<div class="post-fm"><time>23 Jun 2015</time>
			<a href="/tags/">code</a>
		</div>
		<h3>A good CS undergraduate algorithm problem</h3>

	</div>
	<div class="col-md-8 col-sm-12">
		<p>Okay, here’s a question for an undergraduate algorithms class to solve. In a non-relational database, we have a users collection with user preferences for breaking news alerts. In a separate collection, we have news stories with tags and searchable content. We will run a scheduled job that will pair the two and send news alerts to users if a story that matches their alert preferences has been published in the last half hour.</p>

<p>Given that we have approximately 50,000 users with an average of 5 alerts each and 500,000 stories with an average of 20 topics each and ten paragraphs of searchable content, how do we build this job in a way that it won’t crash the database?</p>

<p>Example tables:</p>

<p>users:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[
	{ 
		email: "jane.doe@example.com",
		alerts: [
			{
				type: "open-search",
				term: "Barack Obama"
			},
			{
				type: "topic",
				term: "politics"
			},
			{
				type: "topic",
				term: "congress"
			},
			{
				type: "open-search",
				term: "natural gas"
			},
			{
				type: "open-search",
				term: "solar power"
			}
		]
	},
	{ 
		email: "john.smith@example.com",
		alerts: [
			{
				type: "open-search",
				term: "Joe Biden"
			},
			{
				type: "topic",
				term: "politics"
			},
			{
				type: "open-search",
				term: "sunglasses"
			},
			{
				type: "topic",
				term: "house"
			},
			{
				type: "topic",
				term: "senate"
			},
			{
				type: "open-search",
				term: "solar power"
			}
		]
	},

	....
]
</code></pre></div></div>

<p>stories:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[
	{ 
		headline: "The Standard Lorem Ipsum passage",
		content: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.......",
		tags: [
			{
				term: "Barack Obama"
			},
			{
				term: "president"
			},
			{
				term: "America"
			}
		]
	},
	{ 
		headline: "More lorem ipsum passages",
		content: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.......",
		tags: [
			{
				term: "Joe Biden"
			},
			{
				term: "vice president"
			},
			{
				term: "Senate"
			}
		]
	},
]
</code></pre></div></div>

<p>The end result should look something like:</p>

<p>alerts:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[
	{ 
		email: 'john.doe@example.com',
		stories: [
			{ 
				headline: "More lorem ipsum passages",
				content: "Lorem ipsum dolor..."
			},
			{
				headline: "Another lorem ipsum passage",
				content: "Lorem ipsum dolor..."
			}
		]
	},
	{ 
		email: 'jane.smith@example.com',
		stories: [
			{ 
				headline: "Another lorem ipsum passage",
				content: "Lorem ipsum dolor..."
			},
			{
				headline: "The best of lorem ipsum",
				content: "Lorem ipsum dolor..."
			}
		]
	}
]
</code></pre></div></div>

<p>Would love to hear your questions or solutions: josephmosby@gmail.com</p>

	</div>

</div>


<div class="row">
	<div class="col-md-12">
		<div class="pagination">
			
			<a href="/page4" class="previous">Previous</a>
			

			<span class="page_number">Page: 5 of 11</span>

			
			<a href="/page6" class="next">Next</a>
			
		</div>
	</div>
</div>
		</main>

		<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
		<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
	</body>

</html>
