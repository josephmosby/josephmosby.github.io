<!doctype html>
<html>
	<head>

		<title>josephmosby.com</title>
		<meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" href="/stylesheets/fibonacci.css" />
		<link rel="stylesheet" href="/stylesheets/custom.css" />

		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>

	</head>

	<body>

		<div class="wrapper" id="header">
			<div class="container">
				<div class="row">
					<div class="col-13">
						<a href="/"><h3>JOSEPH MOSBY</h3></a>

						<ul class="menu inline">
							<li><a href="/about">about</a></li>
							<li><a href="/projects">projects</a></li>
							<li><a href="/presentations">presentations</a></li>
							<li><a href="/now">now</a></li>
							<li><a href="/feed/atom.xml">subscribe</a></li>
						</ul>

						<a id="hamburger" href="#">MENU</a>
					</div>
				</div>
			</div>
		</div>

		<div class="wrapper" id="dropdown">
			<div class="container">
				<div class="row">
					<div class="col-13">
						<ul class="menu dropdown">
							<li><a href="/about">about</a></li>
							<li><a href="/projects">projects</a></li>
							<li><a href="/presentations">presentations</a></li>
							<li><a href="/now">now</a></li>
						</ul>
					</div>
				</div>
			</div>
		</div>

		<div class="wrapper" id="main">
			<div class="container">
				<div class="row">
	<div class="col-3">
		<a href="/2015/07/18/trusting-python-and-the-ken-thompson-hack.html"><h3>Trusting Python&comma; and the Ken Thompson hack</h3></a>
	</div>
	<div class="col-8">
		<p>I have always treated Python compilation as a black box. Code goes in, web services come out, everyone is happy. Then I went through <a href="http://www.nand2tetris.org/">NAND2Tetris</a> and picked up a copy of <a href="http://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1437243255&amp;sr=1-1&amp;keywords=the+c+programming+language">The C Programming Language</a>, and it’s been tough to rest as easy ever since. </p>

<p>Python (in its most common derivative, CPython) is not fed straight into a computer’s processor. It’s first “interpreted” into C code, which is then compiled by a C compiler into assembly language, which is then translated into 1’s and 0’s that the computer can actually understand. Let’s take a look at this: </p>

<pre><code>print('Hello, world!')
</code></pre>

<p>That’s the incredibly simple Python code for printing “Hello, world!” Here’s what that looks like in the Python source code:</p>

<pre><code>static PyObject *
builtin_print(PyObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"sep", "end", "file", "flush", 0};
    static PyObject *dummy_args;
    PyObject *sep = NULL, *end = NULL, *file = NULL, *flush = NULL;
    int i, err;

    if (dummy_args == NULL &amp;&amp; !(dummy_args = PyTuple_New(0)))
        return NULL;
    if (!PyArg_ParseTupleAndKeywords(dummy_args, kwds, "|OOOO:print",
                                     kwlist, &amp;sep, &amp;end, &amp;file, &amp;flush))
        return NULL;
    if (file == NULL || file == Py_None) {
        file = _PySys_GetObjectId(&amp;PyId_stdout);
        if (file == NULL) {
            PyErr_SetString(PyExc_RuntimeError, "lost sys.stdout");
            return NULL;
        }

        /* sys.stdout may be None when FILE* stdout isn't connected */
        if (file == Py_None)
            Py_RETURN_NONE;
    }

    if (sep == Py_None) {
        sep = NULL;
    }
    else if (sep &amp;&amp; !PyUnicode_Check(sep)) {
        PyErr_Format(PyExc_TypeError,
                     "sep must be None or a string, not %.200s",
                     sep-&gt;ob_type-&gt;tp_name);
        return NULL;
    }
    if (end == Py_None) {
        end = NULL;
    }
    else if (end &amp;&amp; !PyUnicode_Check(end)) {
        PyErr_Format(PyExc_TypeError,
                     "end must be None or a string, not %.200s",
                     end-&gt;ob_type-&gt;tp_name);
        return NULL;
    }

    for (i = 0; i &lt; PyTuple_Size(args); i++) {
        if (i &gt; 0) {
            if (sep == NULL)
                err = PyFile_WriteString(" ", file);
            else
                err = PyFile_WriteObject(sep, file,
                                         Py_PRINT_RAW);
            if (err)
                return NULL;
        }
        err = PyFile_WriteObject(PyTuple_GetItem(args, i), file,
                                 Py_PRINT_RAW);
        if (err)
            return NULL;
    }

    if (end == NULL)
        err = PyFile_WriteString("\n", file);
    else
        err = PyFile_WriteObject(end, file, Py_PRINT_RAW);
    if (err)
        return NULL;

    if (flush != NULL) {
        PyObject *tmp;
        int do_flush = PyObject_IsTrue(flush);
        if (do_flush == -1)
            return NULL;
        else if (do_flush) {
            tmp = _PyObject_CallMethodId(file, &amp;PyId_flush, "");
            if (tmp == NULL)
                return NULL;
            else
                Py_DECREF(tmp);
        }
    }

    Py_RETURN_NONE;
}
</code></pre>

<p>I understand very little of what’s actually going on here. I do know that ultimately this code has to end up at some sort of terminal output unless I specify otherwise, and I do know that I’ll probably do that by writing to a dedicated terminal output memory location which is probably specified by a C pointer, and this is the extent of my understanding. And we haven’t even made it to assembly code yet. Or to binary instructions. </p>

<p>I go on trusting the CPython interpreter because I have no choice. Perhaps the <code>PyArg_ParseTupleAndKeywords</code> function has a side effect of batching my printed output up and sending it back to a Python mailing list somewhere, for them to laugh at my coding mistakes. Maybe it’s something more nefarious. </p>

<p>I can look through the CPython source code and see that <code>PyArg_ParseTupleAndKeywords</code> does exactly what it says it’s going to. But what if the <em>C compiler itself</em> is batching my printed output up and sending it off? In 1984 Ken Thompson described <a href="http://c2.com/cgi/wiki?TheKenThompsonHack">exactly that</a> with a hack that would allow a compiler to do all sorts of terrible things, including overwriting all evidence of its existence. You could detect it, of course, but you’d have to have a trusted compiler - something that most 2015 developers are not prepared to write. (myself included)</p>

<p>And so I have to trust my computer. I have to trust Intel, Apple, all of the component manufacturers, the <code>gcc</code> team, the CPython team, and everybody in between, because I am not prepared to compute otherwise. </p>

		<a class="twitter-share-button" href="http://twitter.com/share" data-url="http://josephmosby.com/2015/07/18/trusting-python-and-the-ken-thompson-hack.html" data-via="josephmosby">Tweet</a>
	</div>
</div>
			</div>
		</div>

		<div class="wrapper" id="footer">
			<div class="container">
				<div class="row">
					<div class="col-13">
						<p>Brought to you live from Washington, D.C.</p>
					</div>
				</div>
			</div>
		</div>

		<script src="app.js"></script>

		<script>
	
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-45638065-1', 'josephmosby.com');
	    ga('send', 'pageview');
	  
	  	</script>

  		<script>
		window.twttr=(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return;js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);t._e=[];t.ready=function(f){t._e.push(f);};return t;}(document,"script","twitter-wjs"));
		</script>

	</body>

</html>