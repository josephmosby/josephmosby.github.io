---
layout: post
title: Not all software engineers are created equal
tags: product
---

In my first ever technology job, I was the lowest-ranked member of a consulting team. Our team was hired by a federal government agency to help them figure out how to respond to an annual audit of their IT environment - specifically, a Sarbanes-Oxley Section 404 audit. An auditor would come in, tell the agency where there were problems, and we would help agency staff fix those problems. I had never worked in a government agency before. I had never programmed a financial application before. What good was I? How did I earn the title of "ERS Consultant?"

It's easy to get lost in job titles in technology, because we technology professionals deal in a world of tools. `ls` does the same thing every time you run it - it gives you the list of files in a directory. `python manage.py migrate` does the same thing every time you run it - it makes changes to a database based on changes to a Django project. Software engineers have a tendency to fall into a logical trap of thinking we are like the programs we run: repeatable processes that do the same thing each time, perhaps a little faster over time, but ultimately executing our assigned task whenever we're needed. "I am a Django web programmer," we say. "I build Django apps."

If that is how you think of your work, your career is going to sputter. 

When I started in my first-ever technology job, I had tangential experience that was extremely useful in the particular project. I had a master's degree in accountancy, which meant I had gone into _extreme_ detail about Sarbanes-Oxley in my coursework. I could work the technology of that government agency into that mental framework of "controls" and "materiality" and build something better out of that union. I had also interned with the consulting firm before. Though the internship was with a totally different part of the company, I was familiar with the expectations and the systems that powered the organization. And if you've ever taken four hours of a work day trying to find the IT help desk phone line rather than doing something that makes money for the firm, you realize that coming into corporate-world with some pre-existing knowledge is useful.

These things have value to employers. They make you a better technologist. I was not just an "ERS Consultant." I was a technology professional with accounting experience, and that made me disproportionately useful for a Sarbanes-Oxley project.

I was next picked up by a PR firm to code websites for their clients. Turns out, they didn't care about my accounting degree. What they did care about was my experience navigating large organizations and my ability to comfortably interact with clients. 

PR firms do really, really simple technology work. It's all shiny front-end pretty stuff. You're never going to build a machine-learning system that can analyze your client's Twitter presence in real time, but you will learn how to sweat the spacing of letters in a headline just like a print designer. PR firms want the prettiest thing they can get in the shortest amount of time possible, and often the timeline wins out over the features of the site. That's how the industry _works_. You can hope to spend weeks and weeks perfecting an amazing website that showcases all of the wonderful things your client is doing, and it won't matter at all once the PR "moment" is gone. 

You can have a computer science Ph.D. from Stanford and absolutely suck as a developer in a PR firm if you can't be a little bit like a PR pro yourself. That world isn't about technology. It's about words and conversation and making people like you and showing others how they can make people like them, too. And sometimes it involves talking about Sarbanes-Oxley with your client because she has to go into a meeting with a Deloitte auditor who's asking too many questions. Karma sucks.

Not all software engineers are created equal. Some know accounting. Some know journalism. Some know advertising. Find whatever your "one more thing" is and *use it.* Solve problems. When necessary, use code. 